<base target="_parent">
<link rel="stylesheet" href="https://plopgrizzly.github.io/adi/style.css"/>
<div>

<h2>Sprite</h2>
<h3>use adi_screen::Sprite;</h3>
<p>Sprite represents anything that is rendered onto the screen.
</p>

<h4>fn <i>create</i>(<mark>window</mark>: &mut Window, <mark>v</mark>: &[f32],
<mark>style</mark>: Style, <mark>instances</mark>: u32) -> Sprite </h4>
<p>
Create a sprite.  <mark>window</mark> is the window.  <mark>v</mark> is sprite's
vertices.  Format: </p>
<p><span></span>x, y, z, 1.0, <span></span> r, g, b, a,</p>
<p><span></span>x, y, z, 1.0, <span></span> texture coordinate x, texture
	coordinate y, 1.0, 1.0,</p>
<p>
<mark>style</mark> is the Style that will initially be applied to each of the
sprite's instances.  <mark>instances</mark> is the initial number of instances
this sprite should have.
</p>

<h4>fn <i>style</i>(&<mark>self</mark>, <mark>window</mark>: &mut Window, <mark>
i</mark>: usize, <mark>style</mark>: &Style) -> ()</h4>
<p>Change the style of <mark>self</mark> to <mark>style</mark> for instance
<mark>i</mark>.</p>

<h4>fn <i>vertices</i>(&mut <mark>self</mark>, <mark>window</mark>: &mut Window,
<mark>v</mark>: &[f32]) -> ()</h4>
<p>Change the vertices of <mark>self</mark> to <mark>v</mark>.</p>

<h2>Transform</h2>
<h3>use adi_screen::Transform;</h3>
<p>Transform represents a transformation matrix.
</p>

<h4>fn <i>create</i>() -> Transform </h4>
<p>
Create a transform that does nothing.  ( Underneath, this is an identity
matrix ).
</p>

<h4>fn <i>auto</i>(<mark>self</mark>, <mark>window</mark>: &mut Window,
<mark>pos</mark>: (f32, f32)) -> TransformApply</h4>
<p>Multiply by a projection that scales width and height by the smallest widget
size.  The widget is put at position <mark>pos</mark>.  Position isn't affected
by aspect ratio.</p>

<h4>fn <i>orthographic</i>(<mark>self</mark>, <mark>window</mark>: &Window) ->
TransformApply</h4>
<p>Apply an orthographic projection ( depth doesn't change x and y position ).
Note: The return value is TransformApply.</p>

<h4>fn <i>perspective</i>(<mark>self</mark>, <mark>window</mark>: &Window,
<mark>fov</mark>: f32) -> TransformApply</h4>
<p>Apply perspective with <mark>fov</mark> degrees for field of view.  Note: The
return value is TransformApply.</p>

<h4>fn <i>rotate</i>(<mark>self</mark>, <mark>yaw</mark>:f32,
<mark>pitch</mark>:f32, <mark>roll</mark>:f32) -> Transform</h4>
<p>Rotate <mark>self</mark> by <mark>yaw</mark>, <mark>pitch</mark> and
<mark>roll</mark>.</p>

<h4>fn <i>scale</i>(mut <mark>self</mark>, <mark>x</mark>:f32,
<mark>y</mark>:f32, <mark>z</mark>:f32) -> Transform</h4>
<p>Scale <mark>self</mark> by <mark>x</mark>, <mark>y</mark> and <mark>z</mark>.
</p>

<h4>fn <i>translate</i>(mut <mark>self</mark>, <mark>x</mark>:f32,
<mark>y</mark>:f32, <mark>z</mark>:f32) -> Transform</h4>
<p>Translate <mark>self</mark> by <mark>x</mark>, <mark>y</mark> and
<mark>z</mark>.</p>

<h2>TransformApply</h2>
<h3>use adi_screen::TransformApply;</h3>
<p>TransformApply represents a Transform that has been projected using
<i>auto()</i>, <i>orthographic()</i>, or <i>perspective()</i>.
</p>

<h4>fn <i>apply</i>(<mark>self</mark>, <mark>window</mark>: &mut Window,
<mark>sprite</mark>: &Sprite, <mark>i</mark>: usize) -> TransformApply</h4>
<p>Apply a TransformApply onto instance <mark>i</mark> of <mark>Sprite</mark>.
</p>

<hr>
Author: Jeron Aldaron Lau - The Aldaron's Device Interface Documentation Is
Public Domain
</div>
